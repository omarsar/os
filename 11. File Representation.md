## Chapter 11: File Representation

### File System

- File is the smallest allotment of logical secondary storage; 

- Directory consist of the file's name and its unique identifier

- File operations carried provided by the OS
  + Creating a file - find space, then write entry to directory
  + Writing a file - find file, write pointer to keep track of where to write next
  + Reading a file - find file, read pointer to keep track of where to read next
  + Repositioning within a file - find file in directory, reposition current-file position pointer (no i/o required) 
  + Deleting a file - find file, release space, erase the directory entry
  + Truncating a file - find file, delete all other information, and keep all other attributes (e.g., name)

- Open File Table - keeps track of all open file and avoids the need to search the directory all over again.

- Open file - keeps track of the file information as per access by all processes; these include: file pointer, file-open count, disk location of the file, access right;

- current file position pointer - keeps track of read and write pointer

- Internal fragmentation occurs because blocks are not entirely used and the remaining space accumulate to cause fragmentation.

- Access methods:
  + Sequential Access - read and write back and forward from a file
  + Direct Access - random access to read and write

- Any entity (partition) containing a file system is known as a volume (virtual disk). The volume may be a subset of a devise, a whole devise, or multiple devises linked together into a RAID set (used for providing protection from disk failure).

- user file directory (UFD) - in a two level directory every user has a directory; when a user logs in, the system's master file directory (MFD) is searched - the MFd is indexed by user name or account number, and each entry points to the UFD for that user.


- absolute path - contain all the path of a file from the root directory

- relative path - contain the path of a file from the current directory

- Acyclic graph, different from tree structured directory, allows for sharing of files and directories.

- Garbage collection involves traversing the entire file system, marking everything that can be accessed.


### File Implementation


- Index node (Inode) - stores the __disk layout__ of every file in the directory.

- The logical disk layout contains __boot block__, __super block__, __inode list__, __data block__.

- The location information of data blocks is stored in the Inode list.

- Super block contains:
  + how large the file system is
  + how many files it can store
  + where to find the free blocks in the file system
  + what are the free inodes

- For every read/write to a file, the Inode must be referenced because it contains the address and other key information of that file on disk. 

- To speed up the access of a data block from the file system, a copy of the inode list for that directory, called __incore inode__, is stored in main memory. When the inode is stored in the disk it is simply called __disk inode__.

- The disk inode contains the following information:
  + Ownership : who owns a specific file / directory
    * group / individual
  + Type (regular file or directory)
  + Permission field (read/write/execute - rwx)
  + access time
  + modification time
  + inode modified time
  + file size
  + disk address of different data blocks (TOC)

- The __Incore inode__ contains the following information:
  + Status 
      * 1. Locked
      * 2. A process is waiting for inode to become unlocked
      * 3. Changed
      * 4. File (corresponding to inode) changed or not
  + Device no. of File System
  + Inode Identification number (disk inode stored sequentially, therefore, doesn't need an identification number)
  + pointer fields (hash list and free list)
  + Reference Count - number of times inode is being referenced

- Whenever the reference count of an inode becomes 0, then the inode is pushed into the __inode free list__. 

- To access a specific byte in a file, a process must first get information about the address of that file in the inode. The inode is then locked (to avoid any changes) and the block address is obtained from the TOC. After the address has been obtained then the inode is unlocked again. When the inode become locked, no other process can access the file.

- __The inode table of contents (TOC)__:
  + The entries in a TOC contain 12 blocks of address. The first 10 addresses (0-9) contain the addresses of the block which contains file data. They are also called direct pointers.
  + The next address (10) is a __single indirect pointer__ pointing to a block (containing a set of pointers). The set of pointers then point to a block which contains the file data.
  + The next address (11) is a __double indirect pointer__ pointing to a block (containing a set of pointers) which also points to another block containing a set of pointers. The last block of pointers then point to a block that contains the file data.
  + Similarly, the next address (12) contains a __triple indirect pointer__ that follows the same structure as the previous.

```Pascal
// Assuming:
Block Size --> 1 KByte

// then...
Address of Block --> 4 Bytes
Every address block will contain 256 pointers

Direct pointers (10 addresses) can access --> 10 KBytes 
Single Indirect Pointers --> 256 KBytes
Double Indirect Pointers --> 256 X 256 KBytes
Triple Indirect Pointers --> 256 X 256 X 256 KBytes (16 GBytes)
```

- During any file operation:
  + 1. First, check if the inode of that file is in memory (the file could potentially be used by another process)
  + 2. Get a free inode to overwrite with the inode of the new file (obtained from secondary storage).

- Algorithm for getting Inode

```Pascal
While (not done)
  // if inode in memory
  if (inode in inode cache)
    if (inode locked)
      sleep (event: inode is unlocked); // wait for inode to unlock
      continue;
    if (inode on free list) // reference count = 0
      remove inode from free list;
    increment Reference count field;
    return (inode);
  
  // if the inode not in memory
  if (no inode in free list)
    return (error);
  remove (new inode from free list);
  reset inode number and file system;
  remove inode from hash old queue;
  add inode into new hash queue;
  read disk inode from the disk;
  put disk inode into new incore inode (block read algorithm);
  initialize the inode; // reference set to 1
  return (node);
```

- Algorithm for release inode:

```Pascal
lock inode if not already locked;
decrement reference count field;
if (reference == 0)
  if (inode changed)
    update disk inode;
  put inode on free inode list;
release inode lock;
```

- Directory (a special kind of file)

- The type field indicates if the file is a directory or file.

- The content of a directory contains a list of inode numbers and file names as provided in the example below:

| Inode | File Name | Description                |
|-------|-----------|----------------------------|
| 83    | .         | entry of current directory |
| 50    | ..        | entry of parent directory  |
| 61    | passwd    | entry of subdirectory      |
| 30    | bin       | entry of subdirectory      |
| 99    | mkfs      | entry of subdirectory      |
| ...   | ...       | ...                        |

- File path of the subdirectory `passwd` can be specified as `passwd` or `/etc/passwd`.

- Algorithm for converting a path name to the inode number

```Pascal
if (pathname starts from root)
  working inode = root inode;
else
  working inode = current directory;

while (there is more pathname)
  read next pathname component from input;
  verify working directory inode is of directory and access permission okay;
  read directory;

  if (component matches an entry):
    get inode number for matched component;
    release working inode;
    working inode = inode of matched component;

  else:
    return (no inode);
return (working inode);
```

- All the previous algorithms assume that an inode is already bound to a file. This means that for creating a new file there are other operations which are needed to allocate an new inode to a file. The free inode is obtained from the free inode list found in the __super block__.

- The highest inode number in the super block free inode list is called the __remember inode__. This inode indicates where unallocated inodes will be available or free in the disk inode.

- Algorithm for allocating a new inode

```Pascal
while (not done)
  if (super block locked)
    sleep (event: s/b/ become free);
    continue;

  if (s.b. inode list empty)
    lock s.b.
    get remember inode for free inode search;
    search for free inodes until s.b. full OR no more free inodes;
    unlock s.b.l
    wakeup (event: s.b. free);
    if (not free inode found on disk)
      return (no inode);
    set remembered inode;
  
  get inode number from s.b. inode list;
  get inode (iget); // get incore inode
  initialize inode;
  write inode to disk;
  decrement free inode count;
  return (inode);
```

- Algorithm for freeing inode

```Pascal
increment free inode count
if (super block locked)
  return;
if (super block free inode list is full)
  if (inode number requested is less than remembered inode)
    set remembered inode = input inode number;
else
  store inode number in s.b. inode list
return;
```

- The super block also contains a __free data block list__, which is only a single block that contains a list of other data block numbers which are free. 

- A free data block list contains a linked list, which in turn contain pointers to other list of blocks. 

- A data block can never be allocated if its not found in the super data block list. 

- Whenever a block is allocated, a buffer has to also be simultaneously allocated. Only then can the disk block along with allocated buffer be accessed by a process. 

- Algorithm for allocation of disk blocks:

```Pascal
While (s.b. locked)
  sleep (event: s.b. not locked)

remove block no. from s.b. free block list;

if (removed last block from list)
  lock s.b.;
  remove block just taken from free list; // invoke block read algorithm
  copy block numbers into s.b.;
  release block buffer;
  unlock s.b.;
  wakeup process(event: s.b. not locked)

get buffer for block removed from s.b. list; // invoke get block algorithm
initialize buffer
decrement free block count;
mark s.b. modified;
return buffer;
```
